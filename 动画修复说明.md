# 鼓励动画修复说明

## 问题描述

之前的实现中，动画会持续闪烁，而不是每次只显示一次。

## 问题原因

使用布尔值 `show` 来控制动画显示，当状态频繁变化时会导致动画重复触发。

### 之前的实现

```typescript
const [showEncouragement, setShowEncouragement] = useState(false);

// 触发动画
setShowEncouragement(true);

// 组件中
useEffect(() => {
  if (show) {
    // 显示动画
  }
}, [show]); // show 变化时重复触发
```

## 解决方案

改用**触发计数器**模式，确保每次触发都是独立的事件。

### 修复后的实现

#### 1. 使用计数器触发

```typescript
// 使用数字计数器而不是布尔值
const [encouragementTrigger, setEncouragementTrigger] = useState(0);

// 每次触发时递增计数器
const handleShowEncouragement = useCallback(() => {
  setEncouragementTrigger((prev) => prev + 1);
}, []);
```

#### 2. 组件内部防重复机制

```typescript
const lastTriggerRef = useRef(0);

useEffect(() => {
  // 只在 trigger 变化且大于 0 时触发
  if (trigger > 0 && trigger !== lastTriggerRef.current) {
    lastTriggerRef.current = trigger;

    // 显示动画逻辑
    setIsShowing(true);
    setIsVisible(true);

    // 定时器控制显示时长
    // ...
  }
}, [trigger]);
```

## 关键改进

### 1. 触发机制

- **之前**：`show: boolean` - 布尔值切换
- **现在**：`trigger: number` - 计数器递增

### 2. 状态管理

- **之前**：`setShowEncouragement(true/false)` - 可能重复触发
- **现在**：`setEncouragementTrigger(prev => prev + 1)` - 每次都是新值

### 3. 防重复逻辑

- 使用 `useRef` 记录上次触发的值
- 只在值真正变化时执行动画
- 确保每次触发都是独立的

### 4. 显示控制

- `isShowing`：控制组件是否渲染
- `isVisible`：控制淡入淡出动画
- 两层控制确保动画完整播放

## 工作流程

```
用户点击卡片
    ↓
触发 handleShowEncouragement()
    ↓
encouragementTrigger + 1 (例如: 0 → 1)
    ↓
EncouragementToast 检测到 trigger 变化
    ↓
检查 trigger !== lastTriggerRef.current
    ↓
更新 lastTriggerRef.current = trigger
    ↓
显示动画 (isShowing = true, isVisible = true)
    ↓
2.5秒后开始淡出 (isVisible = false)
    ↓
3秒后完全隐藏 (isShowing = false)
    ↓
等待下次触发
```

## 测试场景

### ✅ 正常场景

1. 点击第一张卡片 → 显示动画 → 3 秒后消失
2. 点击第二张卡片 → 显示新的随机动画 → 3 秒后消失
3. 快速点击多张卡片 → 每次都正确显示一次动画

### ✅ 边界场景

1. 动画播放中切换卡片 → 不会中断当前动画
2. 已查看的卡片再次点击 → 不触发动画（由 QuoteCard 控制）
3. 快速连续点击 → 每次触发都独立计数

## 代码对比

### 修复前

```typescript
// page.tsx
const [showEncouragement, setShowEncouragement] = useState(false);
const handleShowEncouragement = () => setShowEncouragement(true);

// EncouragementToast.tsx
interface Props {
  show: boolean;
  onHide: () => void;
}

useEffect(() => {
  if (show) {
    // 可能重复触发
  }
}, [show]);
```

### 修复后

```typescript
// page.tsx
const [encouragementTrigger, setEncouragementTrigger] = useState(0);
const handleShowEncouragement = () =>
  setEncouragementTrigger((prev) => prev + 1);

// EncouragementToast.tsx
interface Props {
  trigger: number;
  onComplete: () => void;
}

const lastTriggerRef = useRef(0);
useEffect(() => {
  if (trigger > 0 && trigger !== lastTriggerRef.current) {
    lastTriggerRef.current = trigger;
    // 确保只触发一次
  }
}, [trigger]);
```

## 优势

1. **可靠性**：每次触发都是独立的，不会相互干扰
2. **可预测**：计数器递增，行为明确
3. **可扩展**：可以轻松添加触发历史记录
4. **性能好**：避免不必要的重复渲染

## 总结

通过将布尔值改为计数器，并添加防重复机制，成功解决了动画持续闪烁的问题。现在每次点击查看答案时，都会显示一次完整的鼓励动画，然后自动消失。
